数据库的锁

# 锁结构
实质上锁信息是在缓冲池上，也就是在内存中。一个锁结构主要包含事务ID，iswaiting, 和锁的类型type。
 
# S / X 独占/共享锁

# 全局锁
Flush tables with read lock --> FTWRL
用于备份时让全库只读。

问题：
1. 在主库备份，业务停摆
2. 在从库备份，备份期间不能执行从主库同步过来的binlog，会导致主从延迟。

通常在MyISAM等不支持MVCC的引擎上使用，因为要保证只读，MVCC的ReadView就可以实现无锁的一致性读。其他事务可以正常的执行更新操作。

# 表锁（偏读）

MyISAM在执行查询语句前会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的所有表加写锁。

MyISAM 的表级锁有两种模式： Table Read Lock/ Table Write Lock

# 行锁（偏写）

InnoDB 实现了行级锁定。
InnoDB 和 MyISAM最大的不同： 1） 支持事务 2）采用了行级锁 3）索引和数据聚集

无索引行锁升级为表锁！！
索引失效行锁升级为表锁！！

# 间隙锁

当使用范围条件检索数据，并请求共享或者排他锁时，InnoDB 会给符合条件的已有数据加锁。对于键值在条件范围之内但并不存在的记录，叫做“间隙(GAP)”。InnoDB 也会对这个间隙加锁，造成在锁定的时候无法插入锁定键值范围内的任何数据。

间隙锁的出现实现了通过加锁来避免幻读的方式。

# 隐式锁

一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id这个牛逼的东东的存在，相当于加了一个隐式锁。别的事务在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。

# 意向锁
IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。

# AUTO_INC锁

针对一条有auto_incrment属性的列的插入会自动获取表级锁，插入执行完成后就立即释放，而不是在事务结束时才释放锁。

除了表级的 auto_inc 锁其实还有轻量级锁可以解决自增的问题。在为插入语句生成AUTO_INCREMENT修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的AUTO_INCREMENT列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。

# 死锁

产生死锁后MySQL的策略：
1. 一直等待，直至超时
2. 死锁检测，发现死锁后，主动回滚死锁链条中的一个事务，让其他事务得以继续执行。

死锁检测时间复杂度高，严重占用CPU性能。

解决方法:
1. 临时关闭死锁检测，风险很高！
2. 在服务端做并发控制。中间件或者修改Mysql源码。基本思路就是对同一行的更新在**进入引擎之前排队**。这样在InnoDB 中就不会有大量的死锁检测工作了。
3. 逻辑上分段。将一条记录拆分成多条记录。例如给一个用户的账户余额拆分成十个记录，这个用户的余额等于这十个用户余额的总和。






